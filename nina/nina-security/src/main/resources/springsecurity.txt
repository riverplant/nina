AuthenticationProvider:提供身份认证逻辑

UserDetails:用户身份信息的接口实现
用户信息通过UserDetailService接口的实现来获取!!!!!!
我们需要自己实现一个UserDetailService，在实现类里定义自己的
HttpBasic认证流程主要是通过BasicAuthenticationFIlter.doFilterInternal()

Session集群管理:通过spring session来自己管理session
<dependency>
        <groupId>org.springframework.session</groupId>
        <artifactId>spring-session-jdbc</artifactId>
      </dependency>
     <dependency>
     
需要自己创建SPRING_SESSION数据库表
***********spring-session-jdbc-2.1.6RELEASE.jar**************************
org.springframework.session.jdbc
schema-mysql.sql

CREATE TABLE SPRING_SESSION (
	PRIMARY_ID CHAR(36) NOT NULL,
	SESSION_ID CHAR(36) NOT NULL,
	CREATION_TIME BIGINT NOT NULL,
	LAST_ACCESS_TIME BIGINT NOT NULL,
	MAX_INACTIVE_INTERVAL INT NOT NULL,
	EXPIRY_TIME BIGINT NOT NULL,
	PRINCIPAL_NAME VARCHAR(100),
	CONSTRAINT SPRING_SESSION_PK PRIMARY KEY (PRIMARY_ID)
) ENGINE=InnoDB ROW_FORMAT=DYNAMIC;

CREATE UNIQUE INDEX SPRING_SESSION_IX1 ON SPRING_SESSION (SESSION_ID);
CREATE INDEX SPRING_SESSION_IX2 ON SPRING_SESSION (EXPIRY_TIME);
CREATE INDEX SPRING_SESSION_IX3 ON SPRING_SESSION (PRINCIPAL_NAME);

CREATE TABLE SPRING_SESSION_ATTRIBUTES (
	SESSION_PRIMARY_ID CHAR(36) NOT NULL,
	ATTRIBUTE_NAME VARCHAR(200) NOT NULL,
	ATTRIBUTE_BYTES BLOB NOT NULL,
	CONSTRAINT SPRING_SESSION_ATTRIBUTES_PK PRIMARY KEY (SESSION_PRIMARY_ID, ATTRIBUTE_NAME),
	CONSTRAINT SPRING_SESSION_ATTRIBUTES_FK FOREIGN KEY (SESSION_PRIMARY_ID) REFERENCES SPRING_SESSION(PRIMARY_ID) ON DELETE CASCADE
) ENGINE=InnoDB ROW_FORMAT=DYNAMIC;
*********************************spring-session-jdbc-2.1.6RELEASE.jar*************


-------------授权------------------------------------------------------
1.GrantedAuthority接口:用户被授予的权限
String getAuthority():返回一串用户权限

2.AbstractSecurityInterceptor: 类似AOP，拦截安全对象
/**
authenticated:通过认证后的用户信息，getPrincipal()可以获得该用户的所有权限
object:用户想要访问的受保护对象
attributes:判断用户是否能访问object的权限规则集合
*/
this.accessDecisionManager.decide(authenticated,object,attributes)


3.ConfigAttribute:需要判断的权限规则

//AccessDecisionVoter:执行具体的判断逻辑
4.AccessDecisionManager -> AbstractAccessDecisionManager
  List<AccessDecisionVoter<? extends Object>> decisionVotes;

  
  AbstractSecurityInterceptor --->
     1.FilterSecurityInterceptor: 用来拦截http请求,通过配置来实现
     
     2.MethodSecurityInterceptor:；用来拦截方法调用,通过在方法上使用注解来实现
     
     3.AccessDecisionManager:通过拦截方法后调用该方法来进行投票
 
 
 ***********************权限设计模型******************************
  Manager:realName,username,password,departement,enable role
  管理员
    多 <------>多
  Role: name, memo, resources, managers
  角色，资源的集合
   多 <------>多
  Resources: name, style,  type, urls, roles
  需要被权限管理的项目
  多 <------>多
  ServiceUrl: className, MethodName, url 
 服务的地址
  ***********************权限设计模型******************************
  
  1.在UserDetailsServiceImpl中，loadUserByUsername方法里返回的
  Collection<? extends GrantedAuthority> authorities：包含该用户所有能访问的url信息
  
  2.当用户访问资源的时候，NinaSecurity.check方法，会通过request.getRequestURI()获得用户想要访问的资源地址
    Object principal = authentication.getPrincipal();
		if (principal != null && principal instanceof UserDetails) {
			/**
			 * 已经成功登录
			 */
          System.out.println(((UserDetails)principal).getAuthorities());
       获得用户能够访问的资源地址
       最后经过比对后返回true或者是false来决定用户是否能访问